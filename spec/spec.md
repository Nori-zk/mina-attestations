# Technical Specification for Mina Credentials

This document is a low-level technical specification for the Mina Credentials system.
It is intended as document for the accompanying codebase and implementators.
It does not include security proofs or motivations for the design choices,
see the RFC for such discussions.

# Metadata

Metadata SHOULD NOT be constrained during the creation of a credential.
Metadata MUST NOT be used to determine the validity of a credential or its issuer.
Metadata MUST only be used to present information about the credential in a human-readable way
inside wallets and other applications for easy identification and selection.

# Formats

## Mina Credential

< HOW A MINA CREDENTIAL IS FORMATTED / STORED >

```javascript
credential = {
  owner: PublicKey,       // the owners public key
  metahash: Field,        // hash of arbitrary metadata
  attributes: Attributes, // struct of hidden attributes (e.g. age, name, SSN)
}
```

## Mina Credential Presentation

```javascript
presentation = {
  proof: Proof,
  claims: Claims,
}
```

The presentation MUST NOT contain the "context" field, which MUST be recomputed by the verifier.

## Mina Credential Metadata

< HOW IS METADATA FORMATTED >


```javascript
metadata = Keccak256.hash(

```

# Protocols

## Presentations

Presentation proofs MUST not be reused.
Presentation proofs MUST be generated for each presentation.


### Public Inputs

```javascript
PublicInput {
  context: Field, // context : specified later
  claims: Claims  // application specific public inputs.
}
```

### Circuit: Present Simple Credential

A standardized circuit for presenting simple credentials.

The circuit verifies two signatures: one from the issuer and one from the owner.

```javascript
// the private inputs for the circuit
PrivateInput {
  credential: Credential,
  issuerPk: PublicKey,
  issuerSignature: Signature,
  ownerSignature: Signature,
}

// hash the credential
let credHash = Poseidon.hashPacked(Credential, credential);

// verify the credential issuer signature
issuerSignature.verify(issuerPk, credHash);

// convert issuerPK to opaque field element
let issuer = Poseidon.hashWithPrefix(
  "mina-cred:v0:simple",  // sep. the domain of "simple" and "recursive" issuers
  issuerPk
);

// verify the credential owners signature
ownerSignature.verify(owner, [credHash, issuer, context]);

// verify application specific constraints using the standard API
applicationConstraints(
  credential, // hidden attributes/owner
  issuer,     // potentially hidden issuer
  claims,     // application specific public input
)
```

### Circuit: Present Recursive Credential

A standardized circuit for presenting recursive credentials.

The circuit verifies a proof "from" the issuing authority and a signature from the owner.

```javascript
// the private inputs for the circuit
PrivateInput {
  vk: VerificationKey,
  credIdent: Field,
  credProof: Proof,
  credential: Credential,
  ownerSignature: Signature,
}

// hash the credential
let credHash = Poseidon.hashPacked(Credential, credential);

// verify the credential proof
credProof.publicInput.assertEquals([credHash, credIdent]);
credProof.verify(vk).assertEqual(true);

// the issuer is identified by the recursive relation and public input
let issuer = Poseidon.hashWithPrefix(
  "mina-cred:v0:recursive", // sep. the domain of "simple" and "recursive" issuers
  [vk.hash, credIdent]      // identifies the issuing authority / validation logic
);

// verify the credential owners signature
ownerSignature.verify(owner, [credHash, issuer, context]);

// verify application specific constraints using the standard API
applicationConstraints(
  credential, // hidden attributes/owner
  issuer,     // potentially hidden issuer
  claims,     // application specific public input
)
```

# Context Binding

The verifier computes the context (out-of-circuit) as:

```javascript
context = Poseidon.hashWithPrefix(
  "mina-cred:v0:context", // for versioning
  [
    // the verification key hash (of the presentation circuit)
    presentationCircuitVK.hash,
    claims,           // the public input (the set of "claims" being presented)
    nonce,            // a random nonce
    verifierIdentity, // a URI for the verifiers identifier (see below)
    action,           // the "action" being performed (e.g. login, transaction hash etc.)
  ]
)
```

The nonce MUST be a uniformly random value generated by the prover.

## ZK App

verifier = Mina address

action = Method with arguments (note one of the args is the presentation proof).


## Web Application

[Uniform Resource Identifier](https://datatracker.ietf.org/doc/html/rfc3986)

```javascript
let verifier = Keccak256.hash("https://example.com/verify");

let action = Keccak256.hash(HTTP_REQUEST);
```

The scheme MUST be `https`.

# Discussion

Discuss the following with Gregor:

1. Should the `issuer` be a struct instead? (e.g. `Issuer { pk: PublicKey, signature: Signature }`)
1. What is the standard way to provide domain-specific for signautures in the Mina ecosystem? should we do:
```
m = Poseidon.hashWithPrefix("mina-cred:v1:", [credHash, issuer, context]);

signature.verifySignedHashV2(message, m);
```
1. Discuss [Nullifiers](https://github.com/o1-labs/o1js/issues/756) in the context of Mina Credentials.
