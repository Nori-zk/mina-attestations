import { Crypto, createEcdsa, createForeignCurve, Bytes, Gadgets } from 'o1js';
import { Credential } from '../credential-index.ts';
import { EcdsaEthereum } from '../credentials/dynamic-ecdsa.ts';
import { DynamicString } from '../dynamic.ts';

class Secp256k1 extends createForeignCurve(Crypto.CurveParams.Secp256k1) {}
class Ecdsa extends createEcdsa(Secp256k1) {}

function StaticEcdsaCredential(messageLength: number) {
  const Message = Bytes(messageLength);
  return Credential.Recursive.fromMethod(
    {
      name: `ecdsa-${messageLength}`,
      publicInput: { signer: { x: Gadgets.Field3, y: Gadgets.Field3 } },
      privateInput: { message: Message, signature: Ecdsa },
      data: { message: Message },
    },
    async ({
      publicInput: {
        signer: { x, y },
      },
      privateInput: { message, signature },
    }) => {
      // convert inputs to Secp256k1
      let signer = Secp256k1.from({ x, y });
      Secp256k1.check(signer); // add constraints

      let ok = signature.verifyEthers(message, signer);
      ok.assertTrue('signature is invalid');
      return { message };
    }
  );
}

// TESTING CODE TO BE REMOVED

let { owner } = await import('../../tests/test-utils.ts');

const EcdsaCredential = await StaticEcdsaCredential(32);
const Bytes32 = Bytes(32);
const String = DynamicString({ maxLength: 200 });

// message signed using ethers.js
let rawMessage = 'Secrets hidden, truth in ZKPs ;)';
let message = Bytes32.fromString(rawMessage);
let messageString = String.from(rawMessage);

// compressed public key generated by ethers.js
let signer = Secp256k1.fromEthers(
  '0x020957928494c38660d254dc03ba78f091a4aea0270afb447f193c4daf6648f02b'
);
let rawSigner = { x: signer.x.value, y: signer.y.value };

// ECDSA signature generated by ethers.js
let signature = Ecdsa.fromHex(
  '0x6fada464c3bc2ae127f8c907c0c4bccbd05ba83a584156edb808b7400346b4c9558598d9c7869f5fd75d81128711f6621e4cb5ba2f52a2a51c46c859f49a833a1b'
);

// out of circuit test
EcdsaEthereum.verify(messageString, signature, signer);

/*
let credDummy = await EcdsaCredential.dummy({
  owner,
  data: { message },
});

console.log(Credential.toJSON(credDummy));

let vk = await EcdsaCredential.compile();
let cred = await EcdsaCredential.create({
  owner,
  publicInput: { signer: rawSigner },
  privateInput: { message, signature },
});

console.log(Credential.toJSON(cred));
*/
